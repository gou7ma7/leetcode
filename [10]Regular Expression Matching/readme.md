# 方法论
很明显前面的状态会影响到之后的匹配情况，因此是很明显的动态规划，  
又因为假如当前匹配时候遇到'.*'这个匹配符号，会影响之前的状态，使用动态规划不如递归描述逻辑简单，
因此使用递归 + 备忘录最优。

# 思路
1. 采用递归(不用最外面的while True了，判定递归出口就行)；
2. 递归出口： 若p已经匹配完成，则检查s，也匹配完(True)，还有剩(False);
3. now_match： 当前开始匹配的状态；
4. 判断p连续两个的情况，分为是否有*（因为*会影响到前一个匹配状态，如果不检查往后一个，就要在检查的时候往前搜索，更加的麻烦；
5. 如果后面紧着的不是*，那么直接返回比较结果；
6. 否则 now_match：s往后走（当前匹配，又*，看当前的这个p是否还能继续往后匹配）；  
not now_match： p往后走（当前不匹配，因为有*，所以直接跳过这个，对p之后的进行比较）。