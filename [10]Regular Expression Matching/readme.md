# lhr
## 方法论
很明显前面的状态会影响到之后的匹配情况，因此是很明显的动态规划，  
又因为假如当前匹配时候遇到'.*'这个匹配符号，会影响之前的状态，使用动态规划不如递归描述逻辑简单，
因此使用递归 + 备忘录最优。

## 思路
1. 采用递归(不用最外面的while True了，判定递归出口就行)；
2. 递归出口： 若p已经匹配完成，则检查s，也匹配完(True)，还有剩(False);
3. now_match： 当前开始匹配的状态；
4. 判断p连续两个的情况，分为是否有*（因为*会影响到前一个匹配状态，如果不检查往后一个，就要在检查的时候往前搜索，更加的麻烦；
5. 如果后面紧着的不是*，那么直接返回比较结果；
6. 否则 now_match：s往后走（当前匹配，又*，看当前的这个p是否还能继续往后匹配）；  
not now_match： p往后走（当前不匹配，因为有*，所以直接跳过这个，对p之后的进行比较）。

## 情况本质
1. 没有*： 一一匹配，然后下一对；
2. \*：匹配0个，s不动，p往下两个，跳过当前字母和紧跟着的*；
3. *：匹配1～n个，p不动，s依次往下匹配；
4. 写递归推导式的是把2、3用or连接；
5. 递归基为s匹配完成 或当前字母匹配失败且p后面没有紧跟着*；

## 做不出来的分析
老生常谈的问题了，还是递推写的不够好，覆盖不了边界情况。
